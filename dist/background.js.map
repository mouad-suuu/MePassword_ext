{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAsE;AACM;AACI;AACH;AACpB;AACE;AAC3D;AACA;AACA,kCAAkC,+EAAoB;AACtD,qCAAqC,qFAAuB;AAC5D,uCAAuC,yFAAyB;AAChE,4BAA4B,sFAAwB;AACpD,wBAAwB,kEAAU;AAClC,0BAA0B,oEAAW;AACrC,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;ACd4B;AACd;AACX;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,qBAAqB,aAAa,IAAI,UAAU;AAC7F;AACA;AACA,+BAA+B,UAAU,SAAS,cAAc;AAChE;AACA,sCAAsC,UAAU,SAAS,cAAc;AACvE;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,gDAAM;AACpC;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE,cAAc;AAC/E,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE,cAAc;AAC/E,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE,cAAc;AAC/E,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAc;AACnD,+CAA+C,sEAAuB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA,6CAA6C,+BAA+B;AAC5E,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjS4C;AACE;AACV,CAAC;AAC9B;AACP;AACA,0BAA0B,qDAAW;AACrC,mBAAmB,qDAAW;AAC9B;AACA,0BAA0B,qDAAW;AACrC,6BAA6B,qDAAW;AACxC;AACA,wBAAwB,qDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,qDAAW;AACzC,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC,qDAAW;AAC5C,uBAAuB,qDAAW;AAClC;AACA,oBAAoB,gDAAM;AAC1B,+BAA+B,qDAAW;AAC1C;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iDAAiD,oBAAoB,oBAAoB;AACzF;AACA;AACA,YAAY,oDAAiB;AAC7B,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,qDAAW;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;ACnGuD;AAChD;AACP;AACA;AACA,kEAAkE,gEAAoB;AACtF;AACA;AACA;AACA;AACA,wBAAwB,gEAAoB;AAC5C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sEAAsE,kBAAkB;AACxF,mEAAmE,kBAAkB;AACrF,uEAAuE,kBAAkB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE,IAAI;AACrE;AACA;AACA;AACA,wFAAwF,mCAAmC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,+EAA+E,kBAAkB;AACjG,4EAA4E,kBAAkB;AAC9F,gFAAgF,kBAAkB;AAClG,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/J4C;AACiB;AACf;AACvC;AACP;AACA;AACA;AACA,gCAAgC,sEAAuB;AACvD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,qDAAW;AAChC;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,qDAAW;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,qDAAW;AAC5B;AACA;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA,QAAQ,oDAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,oDAAiB;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,qDAAW;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yBAAyB,qDAAW;AACpC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,oDAAiB;AAC7B,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7G4C;AACrC;AACP;AACA,iCAAiC,qDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,qDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAW;AAC/C,0BAA0B,qDAAW;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,IAAI,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA,0BAA0B,MAAM;AAChC;AACA,0BAA0B,QAAQ;AAClC;AACA,0BAA0B,QAAQ;AAClC;AACA,0BAA0B,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS,QAAQ,cAAc;AAC3D;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;ACjFiB;AACc;AACI;AACpE;AACA;AACA,sBAAsB,2DAAU;AAChC,6BAA6B,yEAAiB;AAC9C,yBAAyB,6EAAmB;AAC5C,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;ACRgD;AAChB;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,sBAAsB,6BAA6B;AACnD,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,sFAAwB;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,sCAAsC;;;;;;;;;;;;;;;;;;;ACxHe;AACF;AACW;AACJ;AACnD;AACP,iCAAiC;AACjC,wCAAwC,+LAA+L;AACvO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2DAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,cAAc,2DAAU;AACxB;AACA;AACA;AACA;AACA,cAAc,0DAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAU;AACxB;AACA;AACA;AACA;AACA,cAAc,2DAAU,iBAAiB;AACzC,cAAc,2DAAU,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAU;AACzC;AACA;AACA;AACA,QAAQ,mEAAiB;AACzB,QAAQ,mEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAU;AACzC,cAAc,2DAAU;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAe;AACzD;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC,kEAAe;AACxD;AACA,0CAA0C,kEAAe;AACzD;AACA,0EAA0E,eAAe,2DAA2D;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe,qDAAqD;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAe;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvL4D;AACrD,gCAAgC,qEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,GAAG;AAClE,mDAAmD,GAAG;AACtD,iEAAiE,GAAG;AACpE;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpC4D;AACrD,yBAAyB,qEAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,yBAAyB;AACzB,4BAA4B;AAC5B,6BAA6B;AAC7B,oCAAoC;AACpC,oDAAoD;AACpD,gCAAgC;AAChC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrGO;AACP;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA,iEAAe,EAAE,YAAY,EAAC;;;;;;;;;;;;;;;ACD9B,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,8EAA8E,EAAC;;;;;;;;;;;;;;;ACA1K;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVqC;AACrC;AACA,gBAAgB,SAAS;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAQ;AACjB;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;AClCQ;AACN;AACsB;AACjD;AACA,QAAQ,kDAAM;AACd,eAAe,kDAAM;AACrB;AACA;AACA,mDAAmD,+CAAG;AACtD;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,WAAW,8DAAe;AAC1B;AACA,iEAAe,EAAE,EAAC;;;;;;;;;;;;;;;;ACpBa;AAC/B;AACA,uCAAuC,iDAAK;AAC5C;AACA,iEAAe,QAAQ,EAAC;;;;;;;UCJxB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN8D;AAC9D;AACA;AACA,CAAC;AACD;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU,KAAK,QAAQ;AACvF,wBAAwB,wBAAwB,IAAI,iBAAiB;AACrE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAiB;AAC5D;AACA;AACA;AACA;AACA,4CAA4C,mEAAiB;AAC7D,gDAAgD,mEAAiB;AACjE;AACA;AACA;AACA,qBAAqB;AACrB,0BAA0B,mEAAiB;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC","sources":["webpack://mepassword_ext/./src/services/EncryptionService.ts","webpack://mepassword_ext/./src/services/Keys-managment/APIService.ts","webpack://mepassword_ext/./src/services/Keys-managment/CredentialCrypto.ts","webpack://mepassword_ext/./src/services/Keys-managment/CryptoUtils.ts","webpack://mepassword_ext/./src/services/Keys-managment/KeyGeneration.ts","webpack://mepassword_ext/./src/services/Keys-managment/ZeroKnowledgeProof.ts","webpack://mepassword_ext/./src/services/Keys-managment/additionals.ts","webpack://mepassword_ext/./src/services/StorageService.ts","webpack://mepassword_ext/./src/services/auth/WebAuthnService.ts","webpack://mepassword_ext/./src/services/sessionManagment/SessionManager.ts","webpack://mepassword_ext/./src/services/storage/CredentialStorage.ts","webpack://mepassword_ext/./src/services/storage/KeyStorage.ts","webpack://mepassword_ext/./src/services/storage/LocalStorageManager.ts","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/native.js","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/regex.js","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/rng.js","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/v4.js","webpack://mepassword_ext/./node_modules/uuid/dist/esm-browser/validate.js","webpack://mepassword_ext/webpack/bootstrap","webpack://mepassword_ext/webpack/runtime/define property getters","webpack://mepassword_ext/webpack/runtime/hasOwnProperty shorthand","webpack://mepassword_ext/webpack/runtime/make namespace object","webpack://mepassword_ext/./src/background/background.ts"],"sourcesContent":["import { KeyGenerationService } from \"./Keys-managment/KeyGeneration\";\nimport { CredentialCryptoService } from \"./Keys-managment/CredentialCrypto\";\nimport { ZeroKnowledgeProofService } from \"./Keys-managment/ZeroKnowledgeProof\";\nimport { SessionManagementService } from \"./sessionManagment/SessionManager\";\nimport { APIService } from \"./Keys-managment/APIService\";\nimport { CryptoUtils } from \"./Keys-managment/CryptoUtils\";\nclass EncryptionService {\n}\nEncryptionService.KeyGeneration = KeyGenerationService;\nEncryptionService.CredentialCrypto = CredentialCryptoService;\nEncryptionService.ZeroKnowledgeProof = ZeroKnowledgeProofService;\nEncryptionService.Session = SessionManagementService;\nEncryptionService.API = APIService;\nEncryptionService.Utils = CryptoUtils;\nexport default EncryptionService;\n","import { CredentialCryptoService } from \"./CredentialCrypto\";\nimport StoringService from \"../StorageService\";\nimport { v4 as uuidv4 } from \"uuid\";\nexport class APIService {\n    static async handleApiError(error, endpoint) {\n        if (error instanceof Response) {\n            const errorBody = await error\n                .text()\n                .catch(() => \"Unable to read error response\");\n            throw new Error(`API ${endpoint} failed with status ${error.status}: ${errorBody}`);\n        }\n        if (error instanceof Error) {\n            throw new Error(`${endpoint} error: ${error.message}`);\n        }\n        throw new Error(`Unexpected ${endpoint} error: ${String(error)}`);\n    }\n    static async SettingsPost(publicKey) {\n        try {\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/settings`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify({\n                    publicKey: publicKey,\n                    password: decryptedCredentials.password,\n                    deviceId: uuidv4(),\n                    timestamp: Date.now(),\n                }),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"SettingsPost\");\n        }\n    }\n    static async validatePassword(password) {\n        try {\n            console.log(\"Validating the password:\", password);\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/settings/validate`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify({\n                    password: password,\n                }),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            const jsonResponse = await response.json();\n            console.log(\"Password is valid:\", jsonResponse.isValid);\n            return jsonResponse.isValid;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"SettingsPost\");\n        }\n    }\n    static async SettingGet() {\n        try {\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/settings`, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"SettingGet\");\n        }\n    }\n    static async SettingsPut(settings) {\n        const storedKeys = await StoringService.Keys.getKeysFromStorage();\n        try {\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            }).catch((error) => {\n                throw new Error(`Credential decryption failed: ${error.message}`);\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/settings`, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify(settings),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"SettingsPut\");\n        }\n    }\n    static async PasswordsGet() {\n        const storedKeys = await StoringService.Keys.getKeysFromStorage();\n        try {\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/passwords`, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"PasswordsGet\");\n        }\n    }\n    static async PasswordPost(data) {\n        const storedKeys = await StoringService.Keys.getKeysFromStorage();\n        try {\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            }).catch((error) => {\n                throw new Error(`Credential decryption failed: ${error.message}`);\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/passwords`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify(data),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"PasswordPost\");\n        }\n    }\n    static async PasswordPut(data) {\n        const storedKeys = await StoringService.Keys.getKeysFromStorage();\n        try {\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            }).catch((error) => {\n                throw new Error(`Credential decryption failed: ${error.message}`);\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/passwords`, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify(data),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"PasswordPut\");\n        }\n    }\n    static async KeysGet() {\n        try {\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/keys`, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"KeysGet\");\n        }\n    }\n    static async KeysPost(data) {\n        try {\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/keys `, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify(data),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"KeysPost\");\n        }\n    }\n    static async KeysPut(data) {\n        try {\n            const storedKeys = await StoringService.Keys.getKeysFromStorage();\n            const decryptedCredentials = await CredentialCryptoService.decryptCredentials(storedKeys.Credentials, {\n                key: storedKeys.AESKey,\n                iv: storedKeys.IV,\n                algorithm: \"AES-GCM\",\n                length: 256,\n            });\n            const response = await fetch(`${decryptedCredentials.server}/api/passwords`, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${decryptedCredentials.authToken}`,\n                },\n                body: JSON.stringify(data),\n            });\n            if (!response.ok) {\n                throw response;\n            }\n            return response;\n        }\n        catch (error) {\n            return this.handleApiError(error, \"KeysPut\");\n        }\n    }\n}\n","import { CryptoUtils } from \"./CryptoUtils\";\nimport AdditionalMethods from \"./additionals\";\nimport { v4 as uuidv4 } from \"uuid\"; // Importing UUID library\nexport class CredentialCryptoService {\n    static async encryptCredentials(credentials, aesKey) {\n        const key = await CryptoUtils.importAESKey(aesKey.key);\n        const iv = CryptoUtils.base64ToBuffer(aesKey.iv);\n        const encryptedData = {\n            server: await CryptoUtils.encryptString(credentials.server, key, iv),\n            authToken: await CryptoUtils.encryptString(credentials.authToken, key, iv),\n            password: credentials.password\n                ? await CryptoUtils.encryptString(credentials.password, key, iv)\n                : undefined,\n        };\n        const formattedOutput = [\n            \"----------encrypted website----------------\",\n            encryptedData.server,\n            \"----------encrypted authkey----------------\",\n            encryptedData.authToken,\n            credentials.password\n                ? \"----------encrypted password----------------\\n\" +\n                    encryptedData.password\n                : \"\",\n        ].join(\"\\n\");\n        return { encryptedData, formattedOutput };\n    }\n    static async decryptCredentials(encryptedData, aesKey) {\n        try {\n            const key = await CryptoUtils.importAESKey(aesKey.key);\n            const iv = CryptoUtils.base64ToBuffer(aesKey.iv);\n            return {\n                server: await this.decryptString(encryptedData.server, key, iv),\n                authToken: await this.decryptString(encryptedData.authToken, key, iv),\n                password: encryptedData.password\n                    ? await this.decryptString(encryptedData.password, key, iv)\n                    : undefined,\n            };\n        }\n        catch (error) {\n            console.error(\"Decryption failed:\", error);\n            throw new Error(\"Failed to decrypt credentials.\");\n        }\n    }\n    static async encryptPassword(password, keySet) {\n        const method = \"encryptPassword\";\n        console.log(\"[DEBUG] Input password structure:\", {\n            website: (password === null || password === void 0 ? void 0 : password.website) ? \"[PRESENT]\" : \"[MISSING]\",\n            user: (password === null || password === void 0 ? void 0 : password.user) ? \"[PRESENT]\" : \"[MISSING]\",\n            password: (password === null || password === void 0 ? void 0 : password.password) ? \"[PRESENT]\" : \"[MISSING]\",\n        });\n        try {\n            if (!(password === null || password === void 0 ? void 0 : password.website) || !(password === null || password === void 0 ? void 0 : password.user) || !(password === null || password === void 0 ? void 0 : password.password)) {\n                throw new Error(\"Missing required password credentials\");\n            }\n            const aesKey = await CryptoUtils.importAESKey(keySet.AESKey);\n            const iv = CryptoUtils.base64ToBuffer(keySet.IV);\n            const encryptedData = {\n                id: uuidv4(),\n                website: await CryptoUtils.encryptString(password.website, aesKey, iv),\n                user: password.user,\n                password: await CryptoUtils.encryptString(password.password, aesKey, iv),\n            };\n            const metadata = {\n                url: \"test\",\n                title: \"test\",\n                timestamp: \"test\",\n            };\n            console.log(\"[DEBUG] Encrypted data structure:\", {\n                metadata,\n                encryptedDataKeys: Object.keys(encryptedData),\n                ivLength: keySet.IV.length,\n            });\n            return Object.assign(Object.assign({}, encryptedData), { formData: metadata });\n        }\n        catch (error) {\n            AdditionalMethods.logError(method, error);\n            throw new Error(`Failed to encrypt password: ${error.message}`);\n        }\n    }\n    static formatKeyComponents(rsaKeys, aesKey) {\n        return [\n            \"----------public key----------------\",\n            rsaKeys.publicKey.key,\n            \"----------private key----------------\",\n            rsaKeys.privateKey.key,\n            \"----------aes-key----------------\",\n            aesKey.key,\n            \"----------aes-iv----------------\",\n            aesKey.iv,\n        ].join(\"\\n\");\n    }\n    static async decryptString(encryptedData, key, iv) {\n        const decoder = new TextDecoder();\n        const decryptedData = await window.crypto.subtle.decrypt({\n            name: \"AES-GCM\",\n            iv,\n        }, key, CryptoUtils.base64ToBuffer(encryptedData));\n        return decoder.decode(decryptedData);\n    }\n}\n","import { KeyGenerationService } from \"./KeyGeneration\";\nexport class CryptoUtils {\n    static async deriveKey(password) {\n        const encoder = new TextEncoder();\n        const salt = window.crypto.getRandomValues(new Uint8Array(KeyGenerationService.SALT_LENGTH));\n        const baseKey = await window.crypto.subtle.importKey(\"raw\", encoder.encode(password), \"PBKDF2\", false, [\"deriveBits\", \"deriveKey\"]);\n        return window.crypto.subtle.deriveKey({\n            name: \"PBKDF2\",\n            salt,\n            iterations: KeyGenerationService.PBKDF2_ITERATIONS,\n            hash: \"SHA-256\",\n        }, baseKey, {\n            name: \"AES-GCM\",\n            length: 256,\n        }, true, [\"encrypt\", \"decrypt\"]);\n    }\n    static validatePin(pin) {\n        return /^\\d{6}$/.test(pin);\n    }\n    static async encryptString(data, key, iv) {\n        const encoder = new TextEncoder();\n        const encryptedData = await window.crypto.subtle.encrypt({\n            name: \"AES-GCM\",\n            iv,\n        }, key, encoder.encode(data));\n        return this.bufferToBase64(encryptedData);\n    }\n    static async importRSAPublicKey(keyBase64) {\n        const keyData = this.base64ToBuffer(keyBase64);\n        return window.crypto.subtle.importKey(\"spki\", keyData, {\n            name: \"RSA-OAEP\",\n            hash: \"SHA-256\",\n        }, false, [\"encrypt\"]);\n    }\n    static async importAESKey(keyBase64) {\n        const keyData = CryptoUtils.base64ToBuffer(keyBase64);\n        return window.crypto.subtle.importKey(\"raw\", keyData, {\n            name: \"AES-GCM\",\n            length: 256,\n        }, false, [\"encrypt\", \"decrypt\"]);\n    }\n    static async encryptWithRSA(data, publicKey) {\n        const encoder = new TextEncoder();\n        // Encrypt each field separately\n        const encryptedWebsite = await window.crypto.subtle.encrypt({ name: \"RSA-OAEP\" }, publicKey, encoder.encode(data.website));\n        const encryptedUser = await window.crypto.subtle.encrypt({ name: \"RSA-OAEP\" }, publicKey, encoder.encode(data.user));\n        const encryptedPassword = await window.crypto.subtle.encrypt({ name: \"RSA-OAEP\" }, publicKey, encoder.encode(data.password));\n        return {\n            website: this.bufferToBase64(encryptedWebsite),\n            user: this.bufferToBase64(encryptedUser),\n            password: this.bufferToBase64(encryptedPassword),\n        };\n    }\n    static bufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        const binary = bytes.reduce((acc, byte) => acc + String.fromCharCode(byte), \"\");\n        return btoa(binary);\n    }\n    static base64ToBuffer(base64) {\n        try {\n            const cleanBase64 = base64.trim().replace(/\\s/g, \"\");\n            const padded = (() => {\n                const pad = cleanBase64.length % 4;\n                return pad ? cleanBase64 + \"=\".repeat(4 - pad) : cleanBase64;\n            })();\n            if (!/^[A-Za-z0-9+/]*={0,2}$/.test(padded)) {\n                throw new Error(\"Invalid base64 string format\");\n            }\n            const binary = atob(padded);\n            const bytes = new Uint8Array(binary.length);\n            for (let i = 0; i < binary.length; i++) {\n                bytes[i] = binary.charCodeAt(i);\n            }\n            return bytes;\n        }\n        catch (error) {\n            console.error(\"Base64 decoding failed:\", {\n                error,\n                inputLength: base64 === null || base64 === void 0 ? void 0 : base64.length,\n                inputPreview: base64 === null || base64 === void 0 ? void 0 : base64.substring(0, 50),\n            });\n            throw new Error(`Base64 decoding failed: ${error}`);\n        }\n    }\n    static async importRSAPrivateKey(keyBase64) {\n        try {\n            console.log(\"Importing RSA private key\", {\n                keyBase64Preview: keyBase64.substring(0, 50),\n            });\n            if (!keyBase64 || !keyBase64.match(/^[A-Za-z0-9+/]*={0,2}$/)) {\n                throw new Error(\"Invalid base64-encoded RSA private key\");\n            }\n            const keyData = this.base64ToBuffer(keyBase64);\n            const privateKey = await window.crypto.subtle.importKey(\"pkcs8\", keyData, { name: \"RSA-OAEP\", hash: \"SHA-256\" }, false, [\"decrypt\"]);\n            console.log(\"RSA private key imported successfully\");\n            return privateKey;\n        }\n        catch (error) {\n            console.error(\"RSA private key import failed:\", error);\n            throw error;\n        }\n    }\n    static async decryptWithRSA(encryptedData, privateKey) {\n        try {\n            console.log(\"Starting RSA decryption process\", {\n                keyAlgorithm: privateKey.algorithm,\n                keyUsages: privateKey.usages,\n                dataLength: encryptedData === null || encryptedData === void 0 ? void 0 : encryptedData.length,\n            });\n            // Return empty array if no data is provided\n            if (!encryptedData ||\n                !Array.isArray(encryptedData) ||\n                encryptedData.length === 0) {\n                console.log(\"No encrypted data to decrypt, returning empty array\");\n                return [];\n            }\n            const decoder = new TextDecoder(\"utf-8\");\n            const decryptedData = await Promise.all(encryptedData.map(async (item, index) => {\n                var _a, _b, _c, _d, _e, _f;\n                try {\n                    console.log(`Decrypting item ${index}`, {\n                        websiteLength: (_a = item.website) === null || _a === void 0 ? void 0 : _a.length,\n                        userLength: (_b = item.user) === null || _b === void 0 ? void 0 : _b.length,\n                        passwordLength: (_c = item.password) === null || _c === void 0 ? void 0 : _c.length,\n                        websitePreview: (_d = item.website) === null || _d === void 0 ? void 0 : _d.substring(0, 50),\n                        userPreview: (_e = item.user) === null || _e === void 0 ? void 0 : _e.substring(0, 50),\n                        passwordPreview: (_f = item.password) === null || _f === void 0 ? void 0 : _f.substring(0, 50),\n                    });\n                    const websiteBuffer = await window.crypto.subtle.decrypt({ name: \"RSA-OAEP\" }, privateKey, this.base64ToBuffer(item.website));\n                    const userBuffer = await window.crypto.subtle.decrypt({ name: \"RSA-OAEP\" }, privateKey, this.base64ToBuffer(item.user));\n                    const passwordBuffer = await window.crypto.subtle.decrypt({ name: \"RSA-OAEP\" }, privateKey, this.base64ToBuffer(item.password));\n                    console.log(`Successfully decrypted item ${index}`);\n                    console.log(\"RSA decryption process completed successfully\", decoder.decode(websiteBuffer), decoder.decode(userBuffer), decoder.decode(passwordBuffer));\n                    return {\n                        website: decoder.decode(websiteBuffer),\n                        user: decoder.decode(userBuffer),\n                        password: decoder.decode(passwordBuffer),\n                    };\n                }\n                catch (error) {\n                    console.error(`Error decrypting item ${index}:`, error);\n                    return null;\n                }\n            }));\n            const validDecryptedData = decryptedData.filter((item) => item !== null);\n            if (validDecryptedData.length === 0) {\n                throw new Error(\"All decryption attempts failed\");\n            }\n            return validDecryptedData;\n        }\n        catch (error) {\n            console.error(\"RSA decryption error:\", {\n                name: error,\n                message: error,\n                stack: error,\n            });\n            throw error;\n        }\n    }\n}\n","import { CryptoUtils } from \"./CryptoUtils\";\nimport { CredentialCryptoService } from \"./CredentialCrypto\";\nimport AdditionalMethods from \"./additionals\";\nexport class KeyGenerationService {\n    static async generateKeyComponents() {\n        const rsaKeyPair = await this.generateRSAKeyPair();\n        const aesKey = await this.generateAESKey();\n        const formattedOutput = CredentialCryptoService.formatKeyComponents(rsaKeyPair, aesKey);\n        return { rsaKeyPair, aesKey, formattedOutput };\n    }\n    static async generateKeySet(biometricType) {\n        const encryption = await this.generateRSAKeyPair();\n        const dataKey = await this.generateAESKey();\n        return {\n            RSAkeys: encryption,\n            AESKey: dataKey,\n        };\n    }\n    static async generateRSAKeyPair() {\n        if (!window.crypto || !window.crypto.subtle) {\n            throw new Error(\"WebCrypto API is not available\");\n        }\n        const keyPair = await window.crypto.subtle.generateKey({\n            name: \"RSA-OAEP\",\n            modulusLength: 4096,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        }, true, [\"encrypt\", \"decrypt\"]);\n        const publicKeyBuffer = await window.crypto.subtle.exportKey(\"spki\", keyPair.publicKey);\n        const privateKeyBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey);\n        return {\n            publicKey: {\n                key: CryptoUtils.bufferToBase64(publicKeyBuffer),\n                algorithm: \"RSA-OAEP\",\n                length: 4096,\n                format: \"spki\",\n            },\n            privateKey: {\n                key: CryptoUtils.bufferToBase64(privateKeyBuffer),\n                algorithm: \"RSA-OAEP\",\n                length: 4096,\n                format: \"pkcs8\",\n                protected: true,\n            },\n        };\n    }\n    static async generateAESKey() {\n        if (!window.crypto || !window.crypto.subtle) {\n            throw new Error(\"WebCrypto API is not available\");\n        }\n        const iv = window.crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));\n        const key = await window.crypto.subtle.generateKey({\n            name: \"AES-GCM\",\n            length: 256,\n        }, true, [\"encrypt\", \"decrypt\"]);\n        const keyBuffer = await window.crypto.subtle.exportKey(\"raw\", key);\n        return {\n            key: CryptoUtils.bufferToBase64(keyBuffer),\n            algorithm: \"AES-GCM\",\n            length: 256,\n            iv: CryptoUtils.bufferToBase64(iv),\n        };\n    }\n    async generateRSAKeys() {\n        const method = \"generateRSAKeys\";\n        AdditionalMethods.logDebug(method, \"Starting RSA key generation...\");\n        try {\n            // Validate WebCrypto API availability\n            if (!window.crypto || !window.crypto.subtle) {\n                throw new Error(\"WebCrypto API is not available in this environment\");\n            }\n            const keyPair = await window.crypto.subtle.generateKey({\n                name: \"RSA-OAEP\",\n                modulusLength: 4096,\n                publicExponent: new Uint8Array([1, 0, 1]),\n                hash: \"SHA-256\",\n            }, true, [\"encrypt\", \"decrypt\"]);\n            console.log(\"RSA key pair generated successfully\");\n            const publicKeyBuffer = await window.crypto.subtle.exportKey(\"spki\", keyPair.publicKey);\n            const privateKeyBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey);\n            AdditionalMethods.logDebug(method, \"RSA keys generated successfully\", {\n                publicKeyLength: publicKeyBuffer.byteLength,\n                privateKeyLength: privateKeyBuffer.byteLength,\n            });\n            return {\n                publicKey: {\n                    key: CryptoUtils.bufferToBase64(publicKeyBuffer),\n                    algorithm: \"RSA-OAEP\",\n                    length: 4096,\n                    format: \"spki\",\n                },\n                privateKey: {\n                    key: CryptoUtils.bufferToBase64(privateKeyBuffer),\n                    algorithm: \"RSA-OAEP\",\n                    length: 4096,\n                    format: \"pkcs8\",\n                    protected: true,\n                },\n            };\n        }\n        catch (error) {\n            AdditionalMethods.logError(method, error);\n            throw new Error(`Failed to generate RSA keys: ${error.message}`);\n        }\n    }\n}\nKeyGenerationService.SALT_LENGTH = 16;\nKeyGenerationService.IV_LENGTH = 12;\nKeyGenerationService.KEY_LENGTH = 32;\nKeyGenerationService.PBKDF2_ITERATIONS = 100000;\n","import { CryptoUtils } from \"./CryptoUtils\";\nexport class ZeroKnowledgeProofService {\n    static async generateZKP(message, privateKeyBase64) {\n        const privateKey = await CryptoUtils.importRSAPrivateKey(privateKeyBase64);\n        const encoder = new TextEncoder();\n        const data = encoder.encode(message);\n        const signature = await window.crypto.subtle.sign({\n            name: \"RSA-PSS\",\n            saltLength: 32,\n        }, privateKey, data);\n        return {\n            proof: CryptoUtils.bufferToBase64(signature),\n            publicKey: privateKeyBase64, // In a real ZKP system, you'd derive a public key\n        };\n    }\n    static async verifyZKP(message, proofBase64, publicKeyBase64) {\n        try {\n            const publicKey = await CryptoUtils.importRSAPublicKey(publicKeyBase64);\n            const proof = CryptoUtils.base64ToBuffer(proofBase64);\n            const encoder = new TextEncoder();\n            const data = encoder.encode(message);\n            return await window.crypto.subtle.verify({\n                name: \"RSA-PSS\",\n                saltLength: 32,\n            }, publicKey, proof, data);\n        }\n        catch (error) {\n            console.error(\"ZKP verification failed:\", error);\n            return false;\n        }\n    }\n}\n","/**\n * TODO:\n * this file will manage the encryption and decryption of the data.\n * we start with the creation of the account geven the website and the auth key\n * then we create the keys and store them in the local storage and give them to the user\n * we send the asymmetric keys to the server to be stored in the database so the user have ones and the server have the other and bouth needed to decrypt the data, exept the keys that will be used to decrypte the website and the auth key (those will be stored in the database for the session time and by the user)\n * we need a function to decrypte the website and the auth key, then we get the data from the database and decrypt them with the symmetric keys\n * we will use the src/services/db.ts to manage the database and the local storage and use src\\services\\Keys-managment\\SessionManager.ts to manage the session of the user\n *  * Encryption Service\n * TODO: Implement the following functionalities:\n * 1. Key Generation:\n *    - Generate RSA 4096-bit keypairs\n *    - Generate AES-256-GCM keys\n *    - Handle PBKDF2 key derivation\n *\n * 2. Encryption Operations:\n *    - Encrypt/decrypt passwords\n *    - Handle website data encryption\n *    - Manage authentication tokens\n *    - Implement zero-knowledge proofs\n *\n * 3. Key Exchange:\n *    - Secure key transmission\n *    - Key backup encryption\n *    - Organization key sharing\n *\n * 4. Security Measures:\n *    - Implement constant-time operations\n *    - Handle secure random generation\n *    - Protect against timing attacks\n */\nclass AdditionalMethods {\n    static logDebug(method, message, data) {\n        if (this.DEBUG) {\n            console.log(`[EncryptionService:${method}] ${message}`, data || \"\");\n        }\n    }\n    static formatTime(milliseconds) {\n        const days = Math.floor(milliseconds / (1000 * 60 * 60 * 24));\n        const hours = Math.floor(milliseconds / (1000 * 60 * 60));\n        const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));\n        const seconds = Math.floor((milliseconds % (1000 * 60)) / 1000);\n        const ms = milliseconds % 1000;\n        const parts = [];\n        if (days > 0)\n            parts.push(`${days}d`);\n        if (hours > 0)\n            parts.push(`${hours}h`);\n        if (minutes > 0)\n            parts.push(`${minutes}m`);\n        if (seconds > 0)\n            parts.push(`${seconds}s`);\n        if (ms > 0)\n            parts.push(`${ms}ms`);\n        return parts.join(\" \") || \"0ms\";\n    }\n    /**\n     * Logs debug message with execution time\n     */\n    static logTime(message, timeInMs) {\n        if (this.DEBUG) {\n            const formattedTime = this.formatTime(timeInMs);\n            console.log(` ${message} (took ${formattedTime})`);\n        }\n    }\n    // Add session storage property\n    static logError(method, error) {\n        console.error(`[EncryptionService:${method}] Error:`, {\n            message: error.message,\n            stack: error.stack,\n            details: error,\n        });\n    }\n}\nAdditionalMethods.SALT_LENGTH = 16;\nAdditionalMethods.IV_LENGTH = 12;\nAdditionalMethods.KEY_LENGTH = 32;\nAdditionalMethods.PBKDF2_ITERATIONS = 100000;\nAdditionalMethods.DEBUG = true;\n// Add session storage property\nAdditionalMethods.sessionData = new Map();\nexport default AdditionalMethods;\n","import { KeyStorage } from \"./storage/KeyStorage\";\nimport { CredentialStorage } from \"./storage/CredentialStorage\";\nimport { LocalStorageManager } from \"./storage/LocalStorageManager\";\nclass StorageService {\n}\nStorageService.Keys = KeyStorage;\nStorageService.Credentials = CredentialStorage;\nStorageService.Storage = LocalStorageManager;\nexport default StorageService;\n","import { SessionManagementService } from \"../sessionManagment/SessionManager\";\nimport AdditionalMethods from \"../Keys-managment/additionals\";\nexport class WebAuthnService {\n    static async isWebAuthnSupported() {\n        const isSupported = window.PublicKeyCredential !== undefined;\n        console.log(\"WebAuthn support check:\", {\n            isSupported,\n            PublicKeyCredential: !!window.PublicKeyCredential,\n            platform: navigator.platform,\n            userAgent: navigator.userAgent,\n        });\n        return isSupported;\n    }\n    static async registerBiometric(username) {\n        try {\n            console.log(\"Starting biometric registration for user:\", username);\n            if (!(await this.isWebAuthnSupported())) {\n                console.error(\"WebAuthn not supported in this browser\");\n                throw new Error(\"WebAuthn is not supported in this browser\");\n            }\n            const challenge = crypto.getRandomValues(new Uint8Array(32));\n            console.log(\"Generated challenge:\", challenge);\n            const createCredentialOptions = {\n                challenge,\n                rp: {\n                    name: \"MePassword Extension\",\n                    id: window.location.hostname,\n                },\n                user: {\n                    id: Uint8Array.from(username, (c) => c.charCodeAt(0)),\n                    name: username,\n                    displayName: username,\n                },\n                pubKeyCredParams: [\n                    { type: \"public-key\", alg: -7 }, // ES256\n                    { type: \"public-key\", alg: -257 }, // RS256\n                ],\n                timeout: this.AUTH_TIMEOUT,\n                authenticatorSelection: {\n                    authenticatorAttachment: \"platform\", // Use platform authenticator (Windows Hello, Touch ID, etc.)\n                    userVerification: \"required\",\n                    residentKey: \"preferred\",\n                },\n            };\n            console.log(\"Credential options:\", createCredentialOptions);\n            console.log(\"Requesting credential creation...\");\n            const credential = await navigator.credentials.create({\n                publicKey: createCredentialOptions,\n            });\n            console.log(\"Credential created:\", credential);\n            if (credential) {\n                console.log(\"Updating session settings with biometric verification\");\n                const biometricType = this.detectBiometricType();\n                console.log(\"Detected biometric type:\", biometricType);\n                await SessionManagementService.updateSessionSettings({\n                    biometricVerification: true,\n                    biometricType: biometricType,\n                });\n                return true;\n            }\n            console.log(\"Credential creation failed\");\n            return false;\n        }\n        catch (error) {\n            console.error(\"Error in registerBiometric:\", error);\n            AdditionalMethods.logError(\"registerBiometric\", error);\n            throw error;\n        }\n    }\n    static async verifyBiometric() {\n        try {\n            console.log(\"Starting biometric verification\");\n            if (!(await this.isWebAuthnSupported())) {\n                console.log(\"WebAuthn not supported, aborting verification\");\n                return false;\n            }\n            const challenge = crypto.getRandomValues(new Uint8Array(32));\n            console.log(\"Generated verification challenge:\", challenge);\n            const assertionOptions = {\n                challenge,\n                timeout: this.AUTH_TIMEOUT,\n                userVerification: \"required\",\n            };\n            console.log(\"Assertion options:\", assertionOptions);\n            console.log(\"Requesting credential verification...\");\n            const assertion = await navigator.credentials.get({\n                publicKey: assertionOptions,\n            });\n            console.log(\"Verification result:\", assertion);\n            return assertion !== null;\n        }\n        catch (error) {\n            console.error(\"Error in verifyBiometric:\", error);\n            AdditionalMethods.logError(\"verifyBiometric\", error);\n            return false;\n        }\n    }\n    static detectBiometricType() {\n        const ua = navigator.userAgent.toLowerCase();\n        console.log(\"Detecting biometric type for user agent:\", ua);\n        // Check for Windows Hello (Windows 10 and above)\n        if (ua.includes(\"windows nt\") &&\n            parseFloat(ua.split(\"windows nt \")[1]) >= 10.0) {\n            console.log(\"Detected Windows Hello (face recognition)\");\n            return \"face\";\n        }\n        // Check for MacOS Touch ID\n        if (ua.includes(\"macintosh\") || ua.includes(\"mac os x\")) {\n            console.log(\"Detected Touch ID\");\n            return \"fingerprint\";\n        }\n        // Check for Android fingerprint\n        if (ua.includes(\"android\")) {\n            console.log(\"Detected Android fingerprint\");\n            return \"fingerprint\";\n        }\n        console.log(\"Defaulting to face recognition for Windows\");\n        return \"face\"; // Default to face for Windows\n    }\n}\nWebAuthnService.AUTH_TIMEOUT = 60000; // 1 minute\n","import EncryptionService from \"../EncryptionService\";\nimport { KeyStorage } from \"../storage/KeyStorage\";\nimport AdditionalMethods from \"../Keys-managment/additionals\";\nimport { WebAuthnService } from \"../auth/WebAuthnService\";\nexport class SessionManagementService {\n    constructor(userSettings = {}) {\n        this.settings = Object.assign({ autoLockTime: 0, sessionTime: 0, sessionStart: 0, pushNotifications: false, biometricVerification: false, biometricType: \"fingerprint\", autoLockStart: 0, sessionExpiry: 0, lastAccessTime: 0 }, userSettings);\n    }\n    static async initialize() {\n        try {\n            console.log(\"Static initialize called\");\n            const defaultSettings = {\n                autoLockTime: 1000 * 60 * 5,\n                sessionTime: 86400000 * 30,\n                sessionStart: Date.now(),\n                pushNotifications: false,\n                biometricVerification: false,\n                biometricType: \"none\",\n                autoLockStart: Date.now(),\n                sessionExpiry: Date.now() + 86400000 * 30,\n                lastAccessTime: Date.now(),\n            };\n            await KeyStorage.storeSettings(defaultSettings);\n            await SessionManagementService.updateSessionSettings(defaultSettings);\n            console.log(\"Session initialized with default settings:\", defaultSettings);\n        }\n        catch (error) {\n            console.error(\"Failed to initialize session:\", error);\n        }\n    }\n    static async getSessionSettings() {\n        console.log(\"Getting session settings\");\n        if (!this.sessionSettings) {\n            try {\n                this.sessionSettings = await KeyStorage.getSettingsFromStorage();\n                console.log(\"Retrieved settings from storage:\", this.sessionSettings);\n            }\n            catch (error) {\n                console.error(\"Failed to get settings:\", error);\n                throw error;\n            }\n        }\n        else {\n            console.log(\"Using cached session settings:\", this.sessionSettings);\n        }\n        return this.sessionSettings;\n    }\n    static async updateSessionSettings(newSettings) {\n        this.sessionSettings = Object.assign(Object.assign({}, this.sessionSettings), newSettings);\n        console.log(\"Updating session settings.\");\n        await KeyStorage.storeSettings(this.sessionSettings);\n        console.log(\"Session settings updated successfully.\");\n        const settingsType = {\n            sessionSettings: this.sessionSettings,\n        };\n        await EncryptionService.API.SettingsPut(settingsType);\n        console.log(\"Session settings updated in storage.\");\n    }\n    static async getKeys() {\n        if (!this.keys) {\n            console.log(\"Keys not found in memory, retrieving from storage.\");\n            this.keys = await KeyStorage.getKeysFromStorage();\n            console.log(\"Keys retrieved from storage:\", this.keys);\n        }\n        else {\n            console.log(\"Using cached keys:\", this.keys);\n        }\n        return this.keys;\n    }\n    static async updateKeys(newKeys) {\n        this.keys = newKeys;\n        console.log(\"Updating keys.\");\n        await KeyStorage.storeKeys(newKeys);\n        console.log(\"Keys updated successfully.\");\n    }\n    static async clearSession() {\n        console.log(\"Clearing session data.\");\n        await KeyStorage.storeSettings({});\n        await KeyStorage.storeKeys({});\n        this.sessionSettings = null;\n        this.keys = null;\n        console.log(\"Session data cleared.\");\n    }\n    /**\n     * Checks if the session has expired based on session time settings.\n     * Ends the session if the time has exceeded.\n     */\n    async checkSessionExpiration() {\n        try {\n            const settings = await KeyStorage.getSettingsFromStorage();\n            // If no settings exist, we consider the session expired\n            if (!settings || Object.keys(settings).length === 0) {\n                console.log(\"No settings found, considering session expired\");\n                return true;\n            }\n            if (!settings.sessionStart || !settings.sessionTime) {\n                console.log(\"Invalid session settings: missing required fields\");\n                return true;\n            }\n            const currentTime = Date.now();\n            const sessionExpiry = settings.sessionStart + settings.sessionTime;\n            const remainingTime = sessionExpiry - currentTime;\n            AdditionalMethods.logTime(\"Time until session expiry\", remainingTime);\n            AdditionalMethods.logTime(\"Session duration\", settings.sessionTime);\n            return currentTime >= sessionExpiry;\n        }\n        catch (error) {\n            console.log(\"Failed to check session expiration:\", error);\n            return true;\n        }\n    }\n    /**\n     * Starts a short-lock timer for quick reauthentication within a limited time.\n     * Should be called upon successful password entry or biometric verification.\n     */\n    startShortLockTimer() {\n        this.settings.autoLockStart = Date.now();\n    }\n    /**\n     * Checks if the short-lock timer has expired based on auto-lock settings.\n     * Returns true if the user needs to re-authenticate, false otherwise.\n     */\n    async checkShortLockExpiration() {\n        const settings = await KeyStorage.getSettingsFromStorage();\n        const currentTime = Date.now();\n        const shortLockExpiry = settings.autoLockStart + settings.autoLockTime;\n        const remainingTime = shortLockExpiry - currentTime;\n        AdditionalMethods.logTime(\"Time until short lock expiry\", remainingTime);\n        AdditionalMethods.logTime(\"Short lock duration\", settings.autoLockTime);\n        return currentTime <= shortLockExpiry;\n    }\n    /**\n     * Manually triggers short-lock to end early, requiring re-authentication.\n     */\n    async endShortLock() {\n        const settings = await KeyStorage.getSettingsFromStorage();\n        await KeyStorage.updateSettings({\n            autoLockStart: settings.autoLockStart + settings.autoLockTime,\n        });\n    }\n    /**\n     * Enable or disable biometric authentication based on settings.\n     * Ensures that biometric setup is available on the device.\n     */\n    async configureBiometric(enable = true) {\n        try {\n            console.log(\"Configuring biometric:\", enable);\n            if (enable) {\n                const isSupported = await WebAuthnService.isWebAuthnSupported();\n                if (!isSupported) {\n                    throw new Error(\"Biometric authentication is not supported on this device\");\n                }\n                const username = \"user\"; // Get this from your user management system\n                const registered = await WebAuthnService.registerBiometric(username);\n                if (registered) {\n                    const biometricType = WebAuthnService.detectBiometricType();\n                    const settings = await SessionManagementService.getSessionSettings();\n                    const updatedSettings = Object.assign(Object.assign({}, settings), { biometricVerification: true, biometricType: biometricType });\n                    await SessionManagementService.updateSessionSettings(updatedSettings);\n                    console.log(\"Biometric settings updated:\", updatedSettings);\n                }\n                else {\n                    throw new Error(\"Failed to register biometric\");\n                }\n            }\n            else {\n                const settings = await SessionManagementService.getSessionSettings();\n                const updatedSettings = Object.assign(Object.assign({}, settings), { biometricVerification: false, biometricType: \"none\" });\n                await SessionManagementService.updateSessionSettings(updatedSettings);\n                console.log(\"Biometric disabled:\", updatedSettings);\n            }\n        }\n        catch (error) {\n            console.error(\"Error in configureBiometric:\", error);\n            throw error;\n        }\n    }\n    async checkBiometricType() {\n        return WebAuthnService.detectBiometricType();\n    }\n}\n// Simplify static methods to focus on core functionality\nSessionManagementService.sessionSettings = null;\nSessionManagementService.keys = null;\n","import { LocalStorageManager } from \"./LocalStorageManager\";\nexport class CredentialStorage extends LocalStorageManager {\n    static async storeEncryptedCredentials(credentials) {\n        try {\n            this.storeInStorageSync(\"Credentials\", JSON.stringify(credentials));\n        }\n        catch (error) {\n            console.error(`Error storing Credentials`, error);\n        }\n    }\n    static async deleteEncryptedPassword(id) {\n        try {\n            console.log(`Deleting encrypted password for ID: ${id}`);\n            this.deleteFromStorageSync(`password-${id}`);\n            console.log(`Password deleted successfully for ID: ${id}`);\n        }\n        catch (error) {\n            console.error(`Error deleting password for ID: ${id}`, error);\n        }\n    }\n    static async getEncryptedCridentials_Keys() {\n        try {\n            console.log(\"Retrieving encrypted credentials\");\n            const credentialsJSON = await this.getFromStorageSync(\"Keys\");\n            if (credentialsJSON) {\n                const credentials = JSON.parse(credentialsJSON);\n                console.log(\"Retrieved credentials successfully\");\n                return credentials;\n            }\n            return null;\n        }\n        catch (error) {\n            console.error(\"Error retrieving credentials:\", error);\n            return null;\n        }\n    }\n}\n","import { LocalStorageManager } from \"./LocalStorageManager\";\nexport class KeyStorage extends LocalStorageManager {\n    /**\n     * function to get the cridintials from the browser storage\n     * export interface KeySet {\n    privateKey: string;\n    AESKey: string;\n    IV: string;\n    Credentials: UserCredentials;\n  }\n    export interface UserCredentials {\n    server: string;\n    authToken: string;\n    password?: string;\n  }\n     */\n    static async getKeysFromStorage() {\n        try {\n            const keysJSON = await this.getFromStorageSync(\"keys\");\n            if (!keysJSON) {\n                console.log(\"No keys found in storage.\");\n                return {};\n            }\n            const keys = JSON.parse(keysJSON);\n            return keys;\n        }\n        catch (error) {\n            console.error(\"Error retrieving keys from storage:\", error);\n            return {};\n        }\n    }\n    /**\n     * function to post the cridintials from the browser storage\n     */\n    static async storeKeys(keys) {\n        try {\n            console.log(\"Storing keys in storage.\");\n            await this.storeInStorageSync(\"keys\", JSON.stringify(keys));\n            console.log(\"Keys stored successfully.\");\n        }\n        catch (error) {\n            console.error(\"Error storing keys:\", error);\n        }\n    }\n    /**\n     * function to get the session settings from the browser storage\n     * export interface SessionSettings {\n    pushNotifications: boolean; // Toggle notifications\n    autoLockTime: number; // Time in ms or mins before auto-lock\n    autoLockStart: number; // Timestamp of last auto-lock\n    sessionStart: number; // Timestamp when session started\n    sessionTime: number; // Total session time allowed before logout\n    sessionExpiry?: number; // Timestamp for scheduled session expiration\n    lastAccessTime?: number; // Timestamp of last session access (for inactivity checks)\n    biometricVerification: boolean; // Use biometrics for verification\n    biometricType: \"face\" | \"fingerprint\" | \"none\"; // Supported biometric types\n    biometricPassword?: string; // Fallback password if biometrics fail\n    lockOnLeave?: boolean; // Auto-lock on window blur/focus loss\n  }\n     */\n    static async getSettingsFromStorage() {\n        try {\n            const settingsJSON = await this.getFromStorageSync(\"settings\");\n            if (!settingsJSON) {\n                console.log(\"No settings found in storage.\");\n                return {};\n            }\n            const settings = JSON.parse(settingsJSON);\n            return settings;\n        }\n        catch (error) {\n            console.error(\"Error retrieving settings from storage:\", error);\n            return {};\n        }\n    }\n    /**\n     * function to post the session settings from the browser storage\n     */\n    static async storeSettings(settings) {\n        try {\n            console.log(\"Storing settings in storage.\");\n            await this.storeInStorageSync(\"settings\", JSON.stringify(settings));\n            console.log(\"Settings stored successfully.\");\n        }\n        catch (error) {\n            console.error(\"Error storing settings:\", error);\n        }\n    }\n    /**\n     * function to update the session settings from the browser storage\n     */\n    static async updateSettings(newSettings) {\n        try {\n            const currentSettings = await this.getSettingsFromStorage();\n            const updatedSettings = Object.assign(Object.assign({}, currentSettings), newSettings);\n            await this.storeSettings(updatedSettings);\n        }\n        catch (error) {\n            console.error(\"Error updating settings:\", error);\n        }\n    }\n}\n","export class LocalStorageManager {\n    static async storeInStorageSync(key, value) {\n        try {\n            await Promise.resolve(localStorage.setItem(this.STORAGE_PREFIX + key, value));\n        }\n        catch (error) {\n            console.error(`Error storing key \"${key}\" in storage:`, error);\n        }\n    }\n    static async getFromStorageSync(key) {\n        try {\n            return await Promise.resolve(localStorage.getItem(this.STORAGE_PREFIX + key));\n        }\n        catch (error) {\n            console.error(`Error retrieving key \"${key}\" from storage:`, error);\n            return null;\n        }\n    }\n    static async deleteFromStorageSync(key) {\n        try {\n            await Promise.resolve(localStorage.removeItem(this.STORAGE_PREFIX + key));\n        }\n        catch (error) {\n            console.error(`Error deleting key \"${key}\" from storage:`, error);\n        }\n    }\n    static async clearStorage() {\n        try {\n            await Promise.resolve(localStorage.clear());\n        }\n        catch (error) {\n            console.error(\"Error clearing storage:\", error);\n        }\n    }\n}\nLocalStorageManager.STORAGE_PREFIX = \"password-manager-\";\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import EncryptionService from \"../services/EncryptionService\";\nchrome.action.onClicked.addListener((tab) => {\n    console.log(\"Extension icon clicked!\");\n});\nchrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {\n    if (message.type === \"PASSWORD_DETECTED\") {\n        const { website, username, password } = message.data;\n        // Create notification\n        chrome.notifications.create({\n            type: \"basic\",\n            iconUrl: \"assets/icon128.png\",\n            title: \"Save Password?\",\n            message: `Would you like to save the password for ${username} on ${website}?`,\n            buttons: [{ title: \"Save Password\" }, { title: \"Ignore\" }],\n        });\n        // Handle notification button clicks\n        chrome.notifications.onButtonClicked.addListener(async (notificationId, buttonIndex) => {\n            if (buttonIndex === 0) {\n                // Save Password\n                try {\n                    const response = await EncryptionService.API.SettingGet();\n                    const storedKeys = await response.json();\n                    if (!storedKeys.publicKey) {\n                        throw new Error(\"No encryption keys found\");\n                    }\n                    const publicKey = await EncryptionService.Utils.importRSAPublicKey(storedKeys.publicKey);\n                    const encryptedData = await EncryptionService.Utils.encryptWithRSA({\n                        website,\n                        user: username,\n                        password,\n                    }, publicKey);\n                    await EncryptionService.API.PasswordPost({\n                        id: crypto.randomUUID(),\n                        website: encryptedData.website,\n                        user: encryptedData.user,\n                        password: encryptedData.password,\n                    });\n                }\n                catch (error) {\n                    console.error(\"Failed to save password:\", error);\n                }\n            }\n            chrome.notifications.clear(notificationId);\n        });\n    }\n});\n"],"names":[],"sourceRoot":""}